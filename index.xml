<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Инфраструктура ИТ on Инфраструктура ИТ</title>
    <link>https://vitalyzhakov.github.io/</link>
    <description>Recent content in Инфраструктура ИТ on Инфраструктура ИТ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Репликация MySQL-серверов с помощью Docker</title>
      <link>https://vitalyzhakov.github.io/post/mysql-replication-docker/</link>
      <pubDate>Fri, 10 Apr 2020 00:10:06 +0500</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/mysql-replication-docker/</guid>
      <description>

&lt;p&gt;До выхода приложения в бой, нужно смоделировать его поведение
&lt;a href=&#34;https://vitalyzhakov.github.io/post/sandbox-for-web-developers/&#34;&gt;в тестовой среде&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Технология Docker Swarm позволяет легко масштабировать приложение горизонтально.
Но часто приложению приходится обращаться к серверу баз данных, задача масшабировать который гораздо труднее.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vitalyzhakov.github.io/images/several-upstream-one-db.svg&#34; alt=&#34;Много приложений - одна база&#34; title=&#34;Много приложений - одна база&#34; /&gt;&lt;/p&gt;

&lt;p&gt;В нашем случае количество запросов на чтение информации гораздо меньше количества изменений
(есть подозрение, что так на большинстве веб-проектов).
Логичный способ увеличения такого бутылочного горлышка -
увеличить количество баз на чтение и настроить приложение таким образом,
чтобы большее количество запросов на чтение
отправлялось на SLAVE-сервера.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vitalyzhakov.github.io/images/several-upstream-several-dbs.svg&#34; alt=&#34;Много приложений - одна база&#34; title=&#34;Много приложений - много баз&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;предварительная-установка&#34;&gt;Предварительная установка&lt;/h2&gt;

&lt;p&gt;Установить docker, docker-compose на вашу операционную систему.&lt;/p&gt;

&lt;p&gt;Текст далее протестирован на&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ubuntu 18.04&lt;/li&gt;
&lt;li&gt;docker 18.09&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/compose/install/&#34; target=&#34;_blank&#34;&gt;docker-compose&lt;/a&gt; 1.25.4&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;проект&#34;&gt;Проект&lt;/h2&gt;

&lt;p&gt;Создадим папку, где будет располагаться конфигурация серверов&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir db-replication
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;и перейдём в неё&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd db-replication
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Дальнейшие действия будут производиться относительно папки с проектом.&lt;/p&gt;

&lt;h2 id=&#34;настройка-репликации&#34;&gt;Настройка репликации&lt;/h2&gt;

&lt;p&gt;Создадим папку для хранения конфигураций серверов mysql&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p build_env/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;изменение-в-my-cnf-для-каждого-сервера&#34;&gt;Изменение в my.cnf для каждого сервера&lt;/h3&gt;

&lt;p&gt;Каждый сервер должен иметь свой номер.
Master-сервер &lt;code&gt;server-id=1&lt;/code&gt;.
Slave-сервер &lt;code&gt;server-id&amp;gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Конфигурационный файл находится по адресу
&lt;code&gt;/etc/mysql/conf.d/my.cnf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Создадим файл конфигурации master-сервера&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nano build_env/mysql/master.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;с содержимым&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[mysqld]
server-id=1
binlog_format=ROW
log-bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Конфигурация slave1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nano build_env/mysql/slave1.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[mysqld]
server-id=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Конфигурация slave2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nano build_env/mysql/slave2.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[mysqld]
server-id=3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;изменения-при-старте-сервера&#34;&gt;Изменения при старте сервера&lt;/h3&gt;

&lt;p&gt;На master-сервере нужно выдать права пользователю для чтения файла лога&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nano build_env/mysql/master.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE USER repl@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;slavepass&#39;;
GRANT REPLICATION SLAVE ON *.* TO repl@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На slave-сервере нужно указать координаты для подключения к master&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nano build_env/mysql/slave.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CHANGE MASTER TO MASTER_HOST=&#39;db-master&#39;, MASTER_USER=&#39;repl&#39;, MASTER_PASSWORD=&#39;slavepass&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создадим файл для docker-compose&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nano docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;с содержимым&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;version: &#39;3.7&#39;

services:
    mysql:
        image: &#39;percona:8.0&#39;
        container_name: db-master
        volumes:
            - ./build_env/mysql/master.cnf:/etc/my.cnf.d/repl.cnf
            - ./build_env/mysql/master.sql:/docker-entrypoint-initdb.d/start.sql
        environment:
            MYSQL_ROOT_PASSWORD: &amp;quot;secret&amp;quot;

    mysqlread1:
        image: &#39;percona:8.0&#39;
        container_name: db-slave1
        volumes:
            - ./build_env/mysql/slave1.cnf:/etc/my.cnf.d/repl.cnf
            - ./build_env/mysql/slave.sql:/docker-entrypoint-initdb.d/start.sql
        depends_on:
            - mysql
        environment:
            MYSQL_ROOT_PASSWORD: &amp;quot;secret&amp;quot;

    mysqlread2:
        image: &#39;percona:8.0&#39;
        container_name: db-slave2
        volumes:
            - ./build_env/mysql/slave2.cnf:/etc/my.cnf.d/repl.cnf
            - ./build_env/mysql/slave.sql:/docker-entrypoint-initdb.d/start.sql
        depends_on:
            - mysql
        environment:
            MYSQL_ROOT_PASSWORD: &amp;quot;secret&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;запуск&#34;&gt;Запуск&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose rm -vf &amp;amp;&amp;amp; docker-compose up
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;проверка&#34;&gt;Проверка&lt;/h2&gt;

&lt;p&gt;Открываем ещё 1 терминал, заходим в master-сервер&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -it db-master mysql -uroot -psecret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;И ещё 1 терминал, заходим в любой slave&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -it db-slave1 mysql -uroot -psecret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На master выполняем&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Примерный вывод&lt;/p&gt;

&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
| Database           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&lt;/p&gt;

&lt;p&gt;Создадим на master базу данных &lt;code&gt;test&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create database test;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В подключении для slave проверяем, появилась ли созданная на master база данных:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В выводе должна появиться база данных &lt;code&gt;test&lt;/code&gt;.
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
| Database           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&lt;/p&gt;

&lt;h2 id=&#34;диагностика&#34;&gt;Диагностика&lt;/h2&gt;

&lt;p&gt;Для диагностики нужно иметь возможность подключения к консоли mysql.
Подключаемся к master-серверу:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -it db-master mysql -uroot -psecret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Смотрим статус&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show master status;
+-------------------+----------+--------------+------------------+
| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+-------------------+----------+--------------+------------------+
| mysqld-bin.000004 |   119471 |              |                  |
+-------------------+----------+--------------+------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В процессах master-сервера мы можем видеть подключения со SLAVE&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW PROCESSLIST;  
+-------+------+------------------+------+-------------+------+-----------------------------------------------------------------------+------------------+-----------+---------------+-----------+
| Id    | User | Host             | db   | Command     | Time | State                                                                 | Info             | Rows_sent | Rows_examined | Rows_read |
+-------+------+------------------+------+-------------+------+-----------------------------------------------------------------------+------------------+-----------+---------------+-----------+
| 24511 | root | localhost        | NULL | Query       |    0 | NULL                                                                  | SHOW PROCESSLIST |         0 |             0 |         0 |
| 24919 | repl | 172.17.0.7:44536 | NULL | Binlog Dump |    0 | Master has sent all binlog to slave; waiting for binlog to be updated | NULL             |         0 |             0 |         0 |
+-------+------+------------------+------+-------------+------+-----------------------------------------------------------------------+------------------+-----------+---------------+-----------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для slave-сервера&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -it db-slave1 mysql -uroot -psecret
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW SLAVE STATUS;
+----------------------------------+-------------+-------------+-------------+---------------+-------------------------+---------------------+-------------------------------+---------------+-------------------------+------------------+-------------------+-----------------+---------------------+--------------------+------------------------+-------------------------+-----------------------------+------------+------------+--------------+---------------------+-----------------+-----------------+----------------+---------------+--------------------+--------------------+--------------------+-----------------+-------------------+----------------+-----------------------+-------------------------------+---------------+---------------+----------------+----------------+-----------------------------+------------------+--------------------------------------+-------------------------+-----------+---------------------+--------------------------------------------------------+--------------------+-------------+-------------------------+--------------------------+----------------+--------------------+--------------------+-------------------+---------------+----------------------+--------------+--------------------+------------------------+-----------------------+-------------------+
| Slave_IO_State                   | Master_Host | Master_User | Master_Port | Connect_Retry | Master_Log_File         | Read_Master_Log_Pos | Relay_Log_File                | Relay_Log_Pos | Relay_Master_Log_File   | Slave_IO_Running | Slave_SQL_Running | Replicate_Do_DB | Replicate_Ignore_DB | Replicate_Do_Table | Replicate_Ignore_Table | Replicate_Wild_Do_Table | Replicate_Wild_Ignore_Table | Last_Errno | Last_Error | Skip_Counter | Exec_Master_Log_Pos | Relay_Log_Space | Until_Condition | Until_Log_File | Until_Log_Pos | Master_SSL_Allowed | Master_SSL_CA_File | Master_SSL_CA_Path | Master_SSL_Cert | Master_SSL_Cipher | Master_SSL_Key | Seconds_Behind_Master | Master_SSL_Verify_Server_Cert | Last_IO_Errno | Last_IO_Error | Last_SQL_Errno | Last_SQL_Error | Replicate_Ignore_Server_Ids | Master_Server_Id | Master_UUID                          | Master_Info_File        | SQL_Delay | SQL_Remaining_Delay | Slave_SQL_Running_State                                | Master_Retry_Count | Master_Bind | Last_IO_Error_Timestamp | Last_SQL_Error_Timestamp | Master_SSL_Crl | Master_SSL_Crlpath | Retrieved_Gtid_Set | Executed_Gtid_Set | Auto_Position | Replicate_Rewrite_DB | Channel_Name | Master_TLS_Version | Master_public_key_path | Get_master_public_key | Network_Namespace |
+----------------------------------+-------------+-------------+-------------+---------------+-------------------------+---------------------+-------------------------------+---------------+-------------------------+------------------+-------------------+-----------------+---------------------+--------------------+------------------------+-------------------------+-----------------------------+------------+------------+--------------+---------------------+-----------------+-----------------+----------------+---------------+--------------------+--------------------+--------------------+-----------------+-------------------+----------------+-----------------------+-------------------------------+---------------+---------------+----------------+----------------+-----------------------------+------------------+--------------------------------------+-------------------------+-----------+---------------------+--------------------------------------------------------+--------------------+-------------+-------------------------+--------------------------+----------------+--------------------+--------------------+-------------------+---------------+----------------------+--------------+--------------------+------------------------+-----------------------+-------------------+
| Waiting for master to send event | db-master   | repl        |        3306 |            60 | 07a9adad7189-bin.000003 |                 155 | 0c53f622dac3-relay-bin.000005 |           383 | 07a9adad7189-bin.000003 | Yes              | Yes               |                 |                     |                    |                        |                         |                             |          0 |            |            0 |                 155 |         2955798 | None            |                |             0 | No                 |                    |                    |                 |                   |                |                     0 | No                            |             0 |               |              0 |                |                             |                1 | b9bb3878-7c11-11ea-9d4d-0242ac120002 | mysql.slave_master_info |         0 |                NULL | Slave has read all relay log; waiting for more updates |              86400 |             |                         |                          |                |                    |                    |                   |             0 |                      |              |                    |                        |                     0 |                   |
+----------------------------------+-------------+-------------+-------------+---------------+-------------------------+---------------------+-------------------------------+---------------+-------------------------+------------------+-------------------+-----------------+---------------------+--------------------+------------------------+-------------------------+-----------------------------+------------+------------+--------------+---------------------+-----------------+-----------------+----------------+---------------+--------------------+--------------------+--------------------+-----------------+-------------------+----------------+-----------------------+-------------------------------+---------------+---------------+----------------+----------------+-----------------------------+------------------+--------------------------------------+-------------------------+-----------+---------------------+--------------------------------------------------------+--------------------+-------------+-------------------------+--------------------------+----------------+--------------------+--------------------+-------------------+---------------+----------------------+--------------+--------------------+------------------------+-----------------------+-------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Оптимизация скорости загрузки</title>
      <link>https://vitalyzhakov.github.io/post/page-load-time-optimizing/</link>
      <pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/page-load-time-optimizing/</guid>
      <description>

&lt;h2 id=&#34;шаг-1-постановка-цели&#34;&gt;Шаг 1. Постановка цели&lt;/h2&gt;

&lt;p&gt;Основное на этом шаге - определиться, зачем вам оптимизировать
скорость загрузки.
К примеру, у вас сайт-визитка, продаёте вы бани под ключ.
Продажи происходят в той же бане, за столом или по телефону.&lt;/p&gt;

&lt;p&gt;Вполне возможно, что очередная секунда времени загрузки не влияет на продажи и
вложенные затраты не окупятся.&lt;/p&gt;

&lt;p&gt;Стоит сфокусироваться на тех сайтах или страницах, которые влияют на ваши целевые показатели.&lt;/p&gt;

&lt;h2 id=&#34;шаг-2-сбор-статистики-и-выбор-узкого-места-для-оптимизации&#34;&gt;Шаг 2. Сбор статистики и выбор узкого места для оптимизации&lt;/h2&gt;

&lt;p&gt;Во-первых, обратимся к событиям, вызываевым на разных
&lt;a href=&#34;https://www.w3.org/TR/navigation-timing/&#34; target=&#34;_blank&#34;&gt;стадиях загрузки страницы&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.w3.org/TR/navigation-timing/timing-overview.png&#34; alt=&#34;Диаграмма времени загрузки&#34; title=&#34;Диаграмма времени загрузки&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Современные браузеры поддерживают &lt;a href=&#34;https://caniuse.com/#feat=nav-timing&#34; target=&#34;_blank&#34;&gt;Navigation Timing API&lt;/a&gt;,
который предоставляет информацию, когда произошло конкретное событие в течение загрузки страницы.&lt;/p&gt;

&lt;p&gt;Метрики можно смотреть на локальном компьютере либо собирать их с клиента на сервер и затем делать выводы.
У обоих подходов есть плюсы и минусы, давайте их рассмотрим.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Фактор сравнения&lt;/th&gt;
&lt;th&gt;Отслеживание на локальном компьютере&lt;/th&gt;
&lt;th&gt;Развёртывание сервера и выводы в дальшейнем&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Порог входа&lt;/td&gt;
&lt;td&gt;Не требует установки дополнительного ПО&lt;/td&gt;
&lt;td&gt;Требует сервера приёма метрик и их анализа&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Реальность значений&lt;/td&gt;
&lt;td&gt;Только модель, нет конкретных значений&lt;/td&gt;
&lt;td&gt;Данные собраны с реальных пользователей&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Точность результатов&lt;/td&gt;
&lt;td&gt;Результаты меняются от измерения к измерению&lt;/td&gt;
&lt;td&gt;Чем больше посещений страниц, тем точнее результат&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Возможно применение сервисов, которые позволят собрать реальные данные,
не тратя время на равёртывание сервиса сбора метрик.
Например, &lt;code&gt;google analytics&lt;/code&gt; и её отчёт по скорости.&lt;/p&gt;

&lt;p&gt;Субьективно все инструменты делятся на 4 типа:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;встроенные в браузер (debug панель FireFox, Chrome);&lt;/li&gt;
&lt;li&gt;одноразовые сервисы - одно измерение, не отражающее действительность в силу их &lt;a href=&#34;https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C&#34; target=&#34;_blank&#34;&gt;статической незначимости&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;скрипты сбора статистики, встроенные в счётики (Яндекс Метрика, Google Analytics);&lt;/li&gt;
&lt;li&gt;управляемый сбор статистики путём имитации клиента &lt;a href=&#34;https://vitalyzhakov.github.io/post/sitespeed/&#34;&gt;sitespeed.io&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Например, &lt;code&gt;google analytics&lt;/code&gt; по умолчанию собираются метрики по времени загрузки с 1% пользователей.&lt;/p&gt;

&lt;p&gt;При большом количестве просмотров страниц метрики начинают показывать стабильные результаты.&lt;/p&gt;

&lt;p&gt;Но как их улучшить?&lt;/p&gt;

&lt;h2 id=&#34;шаг-3-выявление-узкого-места&#34;&gt;Шаг 3. Выявление узкого места&lt;/h2&gt;

&lt;p&gt;В оптимизации важно применить усилие в нужное место.&lt;/p&gt;

&lt;h3 id=&#34;вариант-за-дёшево&#34;&gt;Вариант &amp;ldquo;за дёшево&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;Заходим в Chromium, запускаем вкладку Audits&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vitalyzhakov.github.io/images/page-load-time-optimizing/chromium-new-audit.png&#34; alt=&#34;Запуск Audit в Chromium&#34; title=&#34;Запуск Audit в Chromium&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Через несколько секунд получаем результат&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vitalyzhakov.github.io/images/page-load-time-optimizing/chromium-audit-result.png&#34; alt=&#34;Результат Audit в Chromium&#34; title=&#34;Результат Audit в Chromium&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lighthouse, встроенный в инструменты разработчика Chromium,
отсортировал для нас факторы оптимизации в порядке приносимых эффектов.&lt;/p&gt;

&lt;p&gt;В данном примере рекомендуют минимизировать работу в главном потоке путём минимизации выполнения JS.&lt;/p&gt;

&lt;h3 id=&#34;вариант-по-статистическим-данным&#34;&gt;Вариант &amp;ldquo;по статистическим данным&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;В &lt;code&gt;google analytics&lt;/code&gt; находим отчёт по скорости загрузки страниц.&lt;/p&gt;

&lt;p&gt;Для наглядности на основе данных я построил диаграмму
&lt;img src=&#34;https://vitalyzhakov.github.io/images/page-load-time-optimizing/timings-from-ga.png&#34; alt=&#34;Page timings&#34; title=&#34;Page timings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Видно, что узкое место - время ответа сервера.
На втором месте - переадресация.&lt;/p&gt;

&lt;p&gt;В таком же порядке стоит начать оптимизировать. Сначала время ответа сервера, затем - уменьшение переадресаций.&lt;/p&gt;

&lt;h2 id=&#34;шаг-4-сама-оптимизация&#34;&gt;Шаг 4. Сама оптимизация&lt;/h2&gt;

&lt;p&gt;В зависимости от узкого места оптимизировать его ;)&lt;/p&gt;

&lt;p&gt;Общие рекомендации для бек-енда:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cчитать данные заранее, клиенту в момент запроса отдавать сразу поготовленные данные;&lt;/li&gt;
&lt;li&gt;Быть гибким для клиента и выдавать только запрошенные поля / выдавать подготовленные данные, подходящие именно для конкретной страницы;&lt;/li&gt;
&lt;li&gt;Стремиться отдавать 90% ответов клиенту за 100ms;&lt;/li&gt;
&lt;li&gt;Исходя из требований времени ответа не допускать запросов при формировании ответов, находящихся на расстоянии больше чем 40-50ms.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Общие &lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/rendering-tools&#34; target=&#34;_blank&#34;&gt;рекомендации для фронт-енда&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Не пишите JavaScript, который заставляет браузер пересчитывать макет страницы.&lt;/li&gt;
&lt;li&gt;Не усложняйте свой CSS. Используйте меньше CSS и делайте ваши CSS-селекторы простыми.&lt;/li&gt;
&lt;li&gt;Исключайте перерисовку где только возможно. Выбирайте CSS, которые не вызывают пересчёт макета страницы целиком.&lt;/li&gt;
&lt;li&gt;Отрисовка страницы может занять больше времени, чем любая другая активность при рендеринге. Следите за узкими местами отрисовки.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/speed/get-started&#34; target=&#34;_blank&#34;&gt;Оптимизация блога кота Тони&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Почему мы не можем повлиять на чужие сайты</title>
      <link>https://vitalyzhakov.github.io/post/why-you-not-influence-aliens-site/</link>
      <pubDate>Thu, 23 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/why-you-not-influence-aliens-site/</guid>
      <description>

&lt;p&gt;Есть различные ресурсы, которые (якобы) выдают некие рекомендации по скорости загрузки страницы конкретного сайта.
Далее будем называть его оптимизируемый сайт.&lt;/p&gt;

&lt;p&gt;Рассмотрим рекомендацию для сайта известного федерального провайдера perm.domru.ru&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vitalyzhakov.github.io/images/why-you-not-influence-alience-site/pagespeed-recomedations.png&#34; alt=&#34;Рекомендации pagespeed&#34; title=&#34;Рекомендации pagespeed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Время жизни кеша задаётся в заголовках http-ответа. Рекомендация состоит в том, чтобы их изменить.&lt;/p&gt;

&lt;p&gt;Как считаете, где надо менять?&lt;/p&gt;

&lt;p&gt;Но пока не отвечайте =)&lt;/p&gt;

&lt;h2 id=&#34;цикл-запроса&#34;&gt;Цикл запроса&lt;/h2&gt;

&lt;p&gt;Рассмотрим последовательность до конкретного ответа.&lt;/p&gt;

&lt;p&gt;Браузер как http-клиент посылает запрос на доменное имя facebook.com&lt;/p&gt;

&lt;p&gt;Компьютеры внутри сети общаются по IP адресам.&lt;/p&gt;

&lt;p&gt;У каждого устройства, подключенного к сети, есть такой адрес.&lt;/p&gt;

&lt;p&gt;DNS-зоны распределяются международными организациями, например, ICANN.&lt;/p&gt;

&lt;p&gt;Внутри зон коммерческим компаниям и физ. лицам разрешается приобрести доменное имя
на определённый срок (обычно, год).&lt;/p&gt;

&lt;p&gt;Затем хозяин домена выставляет IP адрес, который будет выдан DNS-сервером при запросе.&lt;/p&gt;

&lt;p&gt;Чтобы по человекочитаемому (доменному) имени получить IP,
клиентскому устройству нужно сделать запрос к серверу DNS,
который хранит условную таблицу соответствий
между доменным именем и IP адресом.&lt;/p&gt;

&lt;p&gt;Ваше устройство производит запрос к DNS-серверу, далее
запрос уходит по целевому IP адресу, на другом конце сети этот запрос
слушает веб-сервер.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vitalyzhakov.github.io/images/why-you-not-influence-alience-site/dns-and-web.jpg&#34; alt=&#34;Схема обработки запросов в сети Интернет&#34; title=&#34;Схема обработки запросов в сети Интернет&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Веб-сервер выполняет заранее запрограммированные в нём действия, отдавая http-ответ,
включая тело ответа и заголовки.&lt;/p&gt;

&lt;h2 id=&#34;проверь-себя&#34;&gt;Проверь себя&lt;/h2&gt;

&lt;p&gt;Коллеги на веб-сервере оптимизируемого сайта задали конфигурацию:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vitalyzhakov.github.io/images/why-you-not-influence-alience-site/nginx-config.png&#34; alt=&#34;Конфигурация nginx&#34; title=&#34;Конфигурация nginx&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Как вы думаете, будет ли она работать?&lt;/p&gt;

&lt;p&gt;PS. Правильный ответ - нет, запросы на оптимизируемый сайт не придут.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Мониторинг</title>
      <link>https://vitalyzhakov.github.io/post/monitoring/</link>
      <pubDate>Tue, 01 Oct 2019 00:10:06 +0500</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/monitoring/</guid>
      <description>&lt;p&gt;При растущем проекте количество часто сервисов также растёт.&lt;/p&gt;

&lt;p&gt;Команда вносит в них изменения, но не все изменения удаётся протестировать.&lt;/p&gt;

&lt;p&gt;Иногда ошибка проникает в продуктовую среду и по ней нужно отреагировать.&lt;/p&gt;

&lt;p&gt;Один из способов отслеживания - сбор метрик и своевременная реакция на них.
Представьте, что перед вами стоит задача обеспечения здоровья жителей города.
Возможно, стоит периодически измерять показатели здоровья каждого жителя
(температуру, давление, уровень сахара в крови), чтобы своевременно реагировать на изменения и
предотвращать нежелательные последствия.&lt;/p&gt;

&lt;p&gt;Аналогично у команды в продакшне есть сервисы, у них свои показатели на конкретный момент времени.
Для сбора метрик в течение определённого времени используется time series db (например, prometheus).&lt;/p&gt;

&lt;p&gt;В предлагаемом решении в сборе участвуют cadvisior, данные собираются в prometheus.&lt;/p&gt;

&lt;p&gt;Для отображения установлена grafana, в которой можно смотреть показатели во времени.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Прогрессивное развёртывание</title>
      <link>https://vitalyzhakov.github.io/post/progressive-delivery/</link>
      <pubDate>Mon, 30 Sep 2019 00:10:06 +0500</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/progressive-delivery/</guid>
      <description>

&lt;h2 id=&#34;проблематика&#34;&gt;Проблематика&lt;/h2&gt;

&lt;p&gt;В крупные проекты вносится много (больше 10) изменений в день.&lt;/p&gt;

&lt;p&gt;С целью минимизации рисков можно вносить изменения на небольшие группы пользователей,
постепенно увеличивая долю пользователей с новой версией в зависимости от успешности / не успешности метрик.&lt;/p&gt;

&lt;h2 id=&#34;метрики&#34;&gt;Метрики&lt;/h2&gt;

&lt;p&gt;Как видно из постановки проблемы, успешность зависит от нескольких факторов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;длительность принятия решения;&lt;/li&gt;
&lt;li&gt;вероятность принятия неправильного решения;&lt;/li&gt;
&lt;li&gt;количество изменений в единицу времени.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Выводы делаются на основе собираемых данных с сервисов (в идеале технических и бизнес-метрик).&lt;/p&gt;

&lt;h2 id=&#34;реализация&#34;&gt;Реализация&lt;/h2&gt;

&lt;p&gt;Пример в istio &lt;a href=&#34;https://docs.flagger.app/usage/progressive-delivery&#34; target=&#34;_blank&#34;&gt;https://docs.flagger.app/usage/progressive-delivery&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Оптимизация обращений к базе данных</title>
      <link>https://vitalyzhakov.github.io/post/db-optimization/</link>
      <pubDate>Thu, 19 Sep 2019 00:10:06 +0500</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/db-optimization/</guid>
      <description>

&lt;p&gt;При разборе времени генерации ответа от сервера иногда узким местом может быть обращение к СУБД.
Оптимизацию времени доступа к СУБД можно разделить на несколько видов:&lt;/p&gt;

&lt;h2 id=&#34;использование-параметризованных-запросов&#34;&gt;Использование параметризованных запросов&lt;/h2&gt;

&lt;p&gt;Некоторые программисты совершают ошибку, вписывая параметры (например, идентификаторы) запроса сразу в запрос.
Первым шагом СУБД пытается проанализировать запрос. Если параметры приходят в запросе, в кеш запрос не складывается.
Но если параметры прикладывать к запросу, структура запроса не меняется.
Значит, при следующем запросе, есть вероятность нахождения проанализированной структуры в кеше, что позволит ускорить выполнение.&lt;/p&gt;

&lt;h2 id=&#34;размещение-приложения-ближе-к-субд&#34;&gt;Размещение приложения &amp;ldquo;ближе&amp;rdquo; к СУБД&lt;/h2&gt;

&lt;p&gt;Улучшение сетевой связности может положительно сказаться на производительности приложения в целом,
при этом вам не обязательно вносить изменения в код.&lt;/p&gt;

&lt;h2 id=&#34;использование-постоянных-соединений&#34;&gt;Использование постоянных соединений&lt;/h2&gt;

&lt;p&gt;Обычно поднятие соединений занимает значительное количество ресурсов СУБД.
Для исполнения одних и тех же запросов не обязательно поднимать каждый раз новое соединение, можно переиспользовать.
Например, в php это можно сделать одним атрибутом соединения &lt;a href=&#34;https://www.php.net/manual/ru/features.persistent-connections.php&#34; target=&#34;_blank&#34;&gt;https://www.php.net/manual/ru/features.persistent-connections.php&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;написание-хранимых-процедур&#34;&gt;Написание хранимых процедур&lt;/h2&gt;

&lt;p&gt;Порог входа для написания хранимых процедур достаточно высок.
Но если проект высоко нагружен и все остальные спобы оптимизации вы уже перебрали, стоит попробовать.&lt;/p&gt;

&lt;p&gt;Несколько запросов, зависящих друг от друга, можно объединить таким способом и
снизить затраты на сетевой обмен между сервером приложений и сервером баз данных.&lt;/p&gt;

&lt;h2 id=&#34;оптимизация-запросов-и-расстановка-индексов&#34;&gt;Оптимизация запросов и расстановка индексов&lt;/h2&gt;

&lt;p&gt;Здесь подразумевается использование инструментов &lt;code&gt;MySQL SLOW LOG&lt;/code&gt;, &lt;code&gt;explain&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;убираем-лишние-таблицы-данные-из-запросов&#34;&gt;Убираем лишние таблицы / данные из запросов&lt;/h3&gt;

&lt;p&gt;Стоит свежим взглядом осмотреть запросы не предмет неиспользуемых таблиц/полей в запросах.
Это может дать значительный эффект в проект, в который частно вносятся изменения, но при этом рефакторинга
&amp;ldquo;на свежую голову&amp;rdquo; давно не было.&lt;/p&gt;

&lt;h3 id=&#34;расстановка-индексов&#34;&gt;Расстановка индексов&lt;/h3&gt;

&lt;p&gt;Индексы добавляют размера базе данных, но позволяют ускорить запросы.
Стоит поискать баланс с помощью &lt;code&gt;EXPLAIN&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;денормализация-и-объединение-запросов&#34;&gt;Денормализация и объединение запросов&lt;/h2&gt;

&lt;p&gt;Этот вариант требует значительных затрат и модификации.
В большинстве систем данные нормализованы для поддержания целостности.
Но с точки зрения оптимизации времени выборка из одной таблицы обходится дешевле, чем свзязка некольких и выборка из связки.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Запуск lighthouse (chrome audit) без SSL</title>
      <link>https://vitalyzhakov.github.io/post/lighthouse-without-ssl/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/lighthouse-without-ssl/</guid>
      <description>

&lt;p&gt;Не всегда есть возможность использовать валидный SSL для проектов в тестовой среде.&lt;/p&gt;

&lt;p&gt;Для анализа скорости загрузки страниц выпустили lighthouse и
иетегрировали во вкладку инструментов разработчика &lt;code&gt;Audit&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;решение&#34;&gt;Решение&lt;/h2&gt;

&lt;p&gt;1) Получаем содержимое ветки репозитория &lt;a href=&#34;https://github.com/Janpot/lighthouse/tree/ignore-https-errors&#34; target=&#34;_blank&#34;&gt;https://github.com/Janpot/lighthouse/tree/ignore-https-errors&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2) Устанавливаем зависимости&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) Запускаем&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./lighthouse-cli/index.js &amp;lt;url&amp;gt; --ignore-https-errors --view
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Автоматическое тестирование</title>
      <link>https://vitalyzhakov.github.io/post/autotesting/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/autotesting/</guid>
      <description>

&lt;p&gt;На хорошем производстве существует входной и выходной контроль.
Наверное, многие видели на технически сложных изделиях отметки &lt;em&gt;ОТК&lt;/em&gt;, &lt;em&gt;PASSED&lt;/em&gt;,
&lt;em&gt;QUALITY CHECK PASSED&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Приложение, упакованное в контейнер, тоже является технически сложным изделием.
До развёртывания в боевой среде стоит смоделировать его поведение и протестировать.&lt;/p&gt;

&lt;p&gt;Протестировать можно несколькими вариантами:
* отдать заказчику;
* проверить самому;
* написать карточку тестирования;
* написать автоматический тест.&lt;/p&gt;

&lt;p&gt;Рассмотрим задачу публикации предварительно подготовленной промо-страницы в сети Интернет.
Стандартная промо-страница состоит из картинок и текста с относительно неплохим дизайном.
Что на этой странице можно проверять?
* код ответа веб-сервера;
* заголовки ответа веб-сервера;
* текст на наличие ошибок;
* оформление;
* анимацию;
* и т.д.&lt;/p&gt;

&lt;p&gt;Каждый ручной тест отнимает самый дорогой наш ресурс - время.
Допустим, вы реализовали задачу по размещению внутри контейнера этой страницы.
Как другим участникам процесса убедиться в том, что вы сделали то, что было нужно?&lt;/p&gt;

&lt;p&gt;Можно сделать это вручную. А именно - содержать в электронной таблице, в базе знаний,
документах список сценариев и каждый раз их проходить. Вручную.&lt;/p&gt;

&lt;p&gt;Сомневаюсь, что найдутся 100% прилежные люди, которые в состоянии полностью пройти все сценарии (если сценариев больше 100).&lt;/p&gt;

&lt;p&gt;На большом проекте количество вариантов сценариев измеряется десятками (или даже сотнями) тысяч.
Чтобы проводить релизы несколько раз в день, нам нужны сотни прилежных людей.
Понятно, что такого количества людей мы не найдём.&lt;/p&gt;

&lt;p&gt;На этом шаге команды делятся на 2 типа:&lt;/p&gt;

&lt;p&gt;1) тестируют малую часть функционала &amp;ldquo;вручную&amp;rdquo;;
2) заменяют ручное тестирование автоматическим.&lt;/p&gt;

&lt;h2 id=&#34;тестирование-вручную&#34;&gt;Тестирование вручную&lt;/h2&gt;

&lt;p&gt;Например, в программе 10 вариантов развития событий. Можно ли пройти их вручную?
Наверное, да. При этом:&lt;/p&gt;

&lt;p&gt;1) кейсы должны быть описаны в понятном для сотрудника формате;
2) сотрудник должен понимать, где кейсы хранятся, как их пополнять и удалять ненужные
3) сотрудник должен понимать, как проходить по кейсам (как создать площадку, подобную &amp;ldquo;боевой&amp;rdquo;, откуда брать данные для тестирования и т.д.)&lt;/p&gt;

&lt;h2 id=&#34;запуск-автоматических-тестов-локально&#34;&gt;Запуск автоматических тестов локально&lt;/h2&gt;

&lt;p&gt;Запускаем selenium&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d --shm-size=2g --network bridge --name selenium-chrome selenium/standalone-chrome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Узнаём IP адрес созданного контейнера с selenium&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker inspect selenium-chrome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Экспортируем переменные окружения&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export SELENIUM_CHROME_ADDRESS=IP адрес контейнера с selenium
export FQDN=адрес веб-сервера
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ставим зависимости&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer install
#если падает с ошибкой отсутствия какой-либо зависимости, можно вызвать с ключиком --ignore-platform-reqs
composer install --ignore-platform-reqs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Запускаем тесты&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./vendor/bin/codecept run
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Нагрузочное тестирование</title>
      <link>https://vitalyzhakov.github.io/post/load-testing/</link>
      <pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/load-testing/</guid>
      <description>

&lt;h2 id=&#34;проблематика&#34;&gt;Проблематика&lt;/h2&gt;

&lt;p&gt;Запуск нагрузочного тестирования - довольно длительная процедура.&lt;/p&gt;

&lt;p&gt;Если сервис держит нужное количество пользователей или расширение делалось разовыми изменениями параметров конфигруации,
внедрять нагрузочное тестирование в процесс будет только замедлять Time To Market, но не улучшит вопрос качества.&lt;/p&gt;

&lt;h2 id=&#34;подготовка&#34;&gt;Подготовка&lt;/h2&gt;

&lt;h3 id=&#34;договориться-с-заказчиком-об-sl&#34;&gt;Договориться с заказчиком об SL&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;какое максимальное время ответа на каком сценарии должно быть (с распределением;&lt;/li&gt;
&lt;li&gt;какое количество пользователей должен выдерживать сервис в пиках.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;поправить-все-функциональные-баги&#34;&gt;Поправить все функциональные баги&lt;/h3&gt;

&lt;p&gt;Перед тем, как начинать нагрузочное тестирование, нужно убедиться, что перед этим провели функциональное и поправили все баги. Причем именно на вашем стенде. Удостоверьтесь, что в середине вашей стрельбы к вам на стенд никто не придет, чтобы скачать пару сотен гигабайт. В общем, подготовьте удобное тестовое окружение, в котором вам никто не будет мешать.&lt;/p&gt;

&lt;h2 id=&#34;что-тестировать-в-первую-очередь&#34;&gt;Что тестировать в первую очередь&lt;/h2&gt;

&lt;p&gt;Тестировать в первую очередь надо критический сценарий — то есть тот, который приносит деньги.
И провести как минимум два вида тестов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;на разладку, чтобы определить пределы производительности&lt;/li&gt;
&lt;li&gt;на измерение таймингов, чтобы убедиться, что сервис укладывается в SLA.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;То есть сервис обязательно нужно «добить» и померить тайминги на том уровне нагрузки, который предполагается в продакшн.&lt;/p&gt;

&lt;h2 id=&#34;интерпретация-результатов&#34;&gt;Интерпретация результатов&lt;/h2&gt;

&lt;p&gt;Важно смотреть не только итоговую статистику, но и почему она получилась такой.
Найти, что является узким местом.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Переход от монолита к микросервисам</title>
      <link>https://vitalyzhakov.github.io/post/microservices/</link>
      <pubDate>Mon, 26 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/microservices/</guid>
      <description>

&lt;h2 id=&#34;проблематика-больших-монолитных-систем&#34;&gt;Проблематика больших монолитных систем&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Плохое горизонтальное масштабирование&lt;/li&gt;
&lt;li&gt;Плохая отказоустойчивость&lt;/li&gt;
&lt;li&gt;Сложность внедрения новых технологий&lt;/li&gt;
&lt;li&gt;Сложность рефакторинга legacy&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;сравнение-монолита-и-микросервисов&#34;&gt;Сравнение монолита и микросервисов&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Монолит&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Микросервисы по доменам&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://vitalyzhakov.github.io/images/microservices/mono.png&#34; alt=&#34;Монолит&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://vitalyzhakov.github.io/images/microservices/services-by-domain.png&#34; alt=&#34;Микросервисы по доменам&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Плюсы&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Минусы&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Горизонтальное масштабирование только нужных частей&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Дополнительная сложность в тестировании и развёртывании&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Отказоустойчивость&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Выше начальная стоимость&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Масштабирование команд&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Не всегда согласованные данные&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Гибкость стека&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Бывает трудно провести границу между сервисами&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Вам не нужны микросервисы, если&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Вы делаете стартап (MVP)&lt;/li&gt;
&lt;li&gt;Нет или не предполагается рост нагрузки&lt;/li&gt;
&lt;li&gt;Нет плана, как порезать сервисы на слабосвязанные;&lt;/li&gt;
&lt;li&gt;Нет людей, которые могут реализовать процесс внесения изменений.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вам нужны микросервисы, если&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Высокая нагрузка&lt;/li&gt;
&lt;li&gt;Система растет&lt;/li&gt;
&lt;li&gt;Команда растет&lt;/li&gt;
&lt;li&gt;Нужна отказоустойчивость&lt;/li&gt;
&lt;li&gt;Необходимо сократить TTM&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;разбиение&#34;&gt;Разбиение&lt;/h2&gt;

&lt;p&gt;Не разрезайте по слоям, разрезайте по бизнес-контекстам&lt;/p&gt;

&lt;h2 id=&#34;размер-сервиса&#34;&gt;Размер сервиса&lt;/h2&gt;

&lt;p&gt;Размер сервиса выбирается&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;на основе бизнес-контекста;&lt;/li&gt;
&lt;li&gt;на основе сетевых запросов (чем меньше, тем лучше);&lt;/li&gt;
&lt;li&gt;на основе транзакций (транзакция внутри одного сервиса).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;база-данных&#34;&gt;База данных&lt;/h2&gt;

&lt;p&gt;Каждый сервис взаимодействует со своими базами данных (если требуется). Выбор движка зависит от задачи.
В идеале сервис должен быть без сохранения состояния (в литературе StateLess).&lt;/p&gt;

&lt;h2 id=&#34;взаимодействие-между-сервисами&#34;&gt;Взаимодействие между сервисами&lt;/h2&gt;

&lt;p&gt;Асинхронное на основе сервиса очередей (брокера сообщений).
Протокол обмена сообщениями основан на независимом от вендора стандарте.&lt;/p&gt;

&lt;h2 id=&#34;проблемы-обмена-сообщениями-и-решения&#34;&gt;Проблемы обмена сообщениями и решения&lt;/h2&gt;

&lt;p&gt;Проблемы:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Нет ACID-транзакций;&lt;/li&gt;
&lt;li&gt;Возможна несогласованность.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Решение:
На сервере внутри реляционной субд (Postgres, к примеру) сохраняются транзакции с собственным ID события.
Транзакция удаляется, только если она доставлена. Если транзацкция не доставлена, нужно сделать повтор операции.
Давние события игнорируются.&lt;/p&gt;

&lt;h3 id=&#34;трассировка&#34;&gt;Трассировка&lt;/h3&gt;

&lt;p&gt;На основе activity Id: к каждому запросу на верхнем уровне добавляется достаточно уникальный параметр,
который прокидывается внутрь приложений и дальше по цепочке. По нему удобно делать поиск по всем микросервисам.&lt;/p&gt;

&lt;p&gt;Можно воспользоваться готовым решением, например, &lt;a href=&#34;https://opentracing.io/&#34; target=&#34;_blank&#34;&gt;https://opentracing.io/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;развёртывание&#34;&gt;Развёртывание&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Виртуальная машина&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Контейнер + оркестрация (k8s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;AutoScaling – вручную&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AutoScaling – из коробки&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;AutoDiscovery – вручную&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AutoDiscovery - из коробки&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Изоляция по ресурсам из коробки&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Балансировка - из коробки&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;выводы&#34;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Грамотное разбиение на микросервисы даёт преимущества в виде увеличения скорости разработки.
Но для этого нужны специалисты, способные не только писать код, но и развёртывать то, что написано.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git rebase для удалённой ветки</title>
      <link>https://vitalyzhakov.github.io/post/remote-rebase/</link>
      <pubDate>Thu, 30 Aug 2018 00:10:06 +0500</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/remote-rebase/</guid>
      <description>

&lt;h2 id=&#34;командная-строка&#34;&gt;Командная строка&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Клонируем репозиторий с указанием ветки, над которой будет выполнять операцию &lt;em&gt;rebase&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone [Адрес репозитория] -b [ветка]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Выполняем &lt;em&gt;rebase&lt;/em&gt; локально&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git pull --rebase origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Отправка данных на сервер&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push origin [ветка] -f
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Замеры скорости загрузки вебсайтов</title>
      <link>https://vitalyzhakov.github.io/post/sitespeed/</link>
      <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/sitespeed/</guid>
      <description>

&lt;p&gt;Наиболее продвинутые компании на высококонкуретном рынке B2C понимают,
что высокая скорость загрузки сайта положительно сказывается
не только на имидже, но и на показателях конверсии.&lt;/p&gt;

&lt;p&gt;Для того, чтобы что-то оптимизировать, нужно это замерить.
В измерениях нам поможет инструмент под названием &lt;a href=&#34;https://www.sitespeed.io/&#34; target=&#34;_blank&#34;&gt;sitespeed.io&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;В упрощённом варианте можно использовать всего 2 машины - 1 сервер и 1 клиент.
Машины нужны изолированные, так как на измерения клиента не должны влиять операции на сервере.&lt;/p&gt;

&lt;p&gt;Если потребуется, можно нарастить количество клиентов.&lt;/p&gt;

&lt;h2 id=&#34;серверная-сторона&#34;&gt;Серверная сторона&lt;/h2&gt;

&lt;h3 id=&#34;требования&#34;&gt;Требования&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;docker&lt;/li&gt;
&lt;li&gt;docker-compose&lt;/li&gt;
&lt;li&gt;возможность откытия дополнительных портов.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Сервер состоит из СУБД &lt;code&gt;graphite&lt;/code&gt; для хранения измерений и интерфейса &lt;code&gt;grafana&lt;/code&gt; для их отображения.&lt;/p&gt;

&lt;p&gt;Содержимое файла docker-compose.tmpl&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;version: &#39;2&#39;
services:
    graphite:
        image: sitespeedio/graphite
        container_name: sitespeed-graphite
        network_mode: &amp;quot;bridge&amp;quot;
        restart: always
        ports:
            - 2003:2003
    grafana-bootstrap:
        image: sitespeedio/grafana-bootstrap
        container_name: sitespeed-grafana-bootstrap
        network_mode: &amp;quot;bridge&amp;quot;
        depends_on:
            - grafana
        links:
            - grafana
        environment:
            - GF_PASSWORD=**                    # заменить на пароль
            - GF_USER=*                         # заменить на имя пользователя
    grafana:
        image: grafana/grafana
        container_name: sitespeed-grafana
        network_mode: &amp;quot;bridge&amp;quot;
        depends_on:
            - graphite
        links:
            - graphite
        environment:
            - GF_SECURITY_ADMIN_PASSWORD=**     # заменить на пароль
            - GF_SECURITY_ADMIN_USER=*          # заменить на имя пользователя
            - GF_AUTH_ANONYMOUS_ENABLED=true
            - GF_USERS_ALLOW_SIGN_UP=false
            - GF_USERS_ALLOW_ORG_CREATE=false
        ports:
            - 80:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Входящие соединения с клиентов на порт &lt;code&gt;2003&lt;/code&gt; прокидываются в контейнер с &lt;code&gt;graphite&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Первичный запуск с инициализацией стандартных панелей sitespeed в grafana:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    - docker-compose up -d
    - docker-compose run --rm grafana-bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;клиент&#34;&gt;Клиент&lt;/h2&gt;

&lt;h3 id=&#34;требования-1&#34;&gt;Требования&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;docker&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Пример запуска сбора данных в crontab раз в 10 минут&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;*/10 * * * * docker run -v /etc/sitespeed.io/urls.txt:/sitespeed.io/urls.txt sitespeedio/sitespeed.io urls.txt --graphite.host=[хост с сервером]  -n 1 --speedIndex false --video false -c 3g &amp;gt;&amp;gt; /tmp/sitespeed.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Файл &lt;code&gt;urls.txt&lt;/code&gt; содержит список страниц, которые нужно проверить:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://yandex.ru
https://мой-быстрый-сайт.рф
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Соединение должно быть фиксированным (&lt;code&gt;-c 3g&lt;/code&gt; означает иммитацию 3G),
чтобы снизить зависимость измерений от сетевых проблем.&lt;/p&gt;

&lt;h3 id=&#34;несколько-клиентов&#34;&gt;Несколько клиентов&lt;/h3&gt;

&lt;p&gt;Если проект развивается и появилась возможность мониторить время загрузки страниц
с разных провайдеров, сетей, географических зон, добавьте в crontab клиента&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--graphite.namespace sitespeed_io.perm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В этом примере &lt;code&gt;perm&lt;/code&gt; означает, что замеры производятся в городе Пермь.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Автоматическая проверка переадресации с помощью Codeception</title>
      <link>https://vitalyzhakov.github.io/post/redirect-autotest/</link>
      <pubDate>Tue, 05 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/redirect-autotest/</guid>
      <description>&lt;p&gt;Рассмотрим реализацию теста, который подтверждает (проверяет) переадресацию пользователя на определённый URL.&lt;/p&gt;

&lt;p&gt;На самом деле нам не нужно проверять, что пользователь перешёл на целевой URL.
Задача веб-сервера заключается в том, чтобы отправить клиенту
верный http-ответ с корректным заголовком и правильным статусом.&lt;/p&gt;

&lt;p&gt;Далее уже клиент решает, переходить ему по этому URL или нет.&lt;/p&gt;

&lt;p&gt;Пример конфигурации &lt;code&gt;rest.suite.yml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;actor: RestTester
modules:
    enabled:
        - REST:
            depends: PhpBrowser
            url: http://адрес-сервера

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пример автоматической проверки&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class RedirectCest{
    public function autodiscoverRedirect(RestTester $I) {
        $I-&amp;gt;stopFollowingRedirects(); // запрещаем переходить по URL, чтобы отследить ответ сервера
        $I-&amp;gt;sendGET(&#39;/autodiscover/autodiscover.xml&#39;); // делаем запрос
        $I-&amp;gt;seeResponseCodeIs(302); // Проверяем код ответа (302 или 301)
        $I-&amp;gt;seeHttpHeader(&#39;Location&#39;, &#39;https://vnytve.ru&#39;); // Проверяем целевой URL для клиента
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Таким образом мы убеждаемся в присутствии переадресации при определённом запросе пользователя на веб-сервер.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Тестирование API-интерфейсов над большими системами</title>
      <link>https://vitalyzhakov.github.io/post/rest-api-testing/</link>
      <pubDate>Thu, 31 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/rest-api-testing/</guid>
      <description>

&lt;h2 id=&#34;постановка-задачи&#34;&gt;Постановка задачи&lt;/h2&gt;

&lt;p&gt;Протестировать автоматическими скриптами валидность ответов API над большой системой.&lt;/p&gt;

&lt;h2 id=&#34;решение&#34;&gt;Решение&lt;/h2&gt;

&lt;p&gt;Для решения нам понадобится &lt;a href=&#34;https://vitalyzhakov.github.io/post/qa-api&#34;&gt;QA API&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;В общем случае процесс выглядит следующим образом:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;скрипт с помощью &lt;a href=&#34;https://vitalyzhakov.github.io/post/qa-api&#34;&gt;QA API&lt;/a&gt; создаёт элемент данных, над которым будем проводить операции в проверяемом API.&lt;/li&gt;
&lt;li&gt;скрипт выполняет API-запросы с созданными элементами данных, для которых заранее известен ответ.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;пример-системы-личный-кабинет&#34;&gt;Пример системы - личный кабинет&lt;/h2&gt;

&lt;p&gt;Протестируем API баланса личного кабинета пользователя.&lt;/p&gt;

&lt;p&gt;Для этого:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;С помощью &lt;a href=&#34;https://vitalyzhakov.github.io/post/qa-api&#34;&gt;QA API&lt;/a&gt; создадим пользователя с указанным начальным значением баланса;&lt;/li&gt;
&lt;li&gt;С помощью rest API авторизуемся под пользователем;&lt;/li&gt;
&lt;li&gt;С помощью rest API проверим текущий баланс пользователя, сравним с балансом в пункте 1. Значения должны совпадать.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Замечу, что при выполнении на непродуктовой базе влияния на сервис нет совсем (ни по нагрузке, ни по изменяемым данным). Последним обычно грешат стандартные способы проверки без использования &lt;a href=&#34;https://vitalyzhakov.github.io/post/qa-api&#34;&gt;QA API&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>API для автоматического тестирования</title>
      <link>https://vitalyzhakov.github.io/post/qa-api/</link>
      <pubDate>Wed, 16 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://vitalyzhakov.github.io/post/qa-api/</guid>
      <description>

&lt;p&gt;В небольших проектах для воспроизведения тестов можно пользоваться следующим шагами:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;создать виртуальную машину (контейнер) с СУБД;&lt;/li&gt;
&lt;li&gt;восстановить СУБД с продуктовой среды из дампа;&lt;/li&gt;
&lt;li&gt;применить миграции.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;суть-проблемы&#34;&gt;Суть проблемы&lt;/h2&gt;

&lt;p&gt;При больших базах даннных время восстановления может измеряться часами.
Если мы ставим целью прохождение тестов в течение короткого интервала времени (до 10 минут), нам нужен другой подход.&lt;/p&gt;

&lt;h2 id=&#34;решение&#34;&gt;Решение&lt;/h2&gt;

&lt;p&gt;При написании обычного API программисты backend также пишут API для тестирования, которое создаёт сущности в бек-енде.&lt;/p&gt;

&lt;p&gt;Например, для социальной сети это может быть содание &lt;code&gt;аккаунта пользователя&lt;/code&gt;
с нужными для проведения тестировния атрибуами (возраст, пол, вес, интересы).&lt;/p&gt;

&lt;p&gt;В случае оператора связи сущностью может быть &lt;code&gt;договор на оказание услуг&lt;/code&gt; с атрибутами баланс, подключенные услуги.&lt;/p&gt;

&lt;p&gt;Тогда цикл работы теста может быть описан следующим образом:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Подготовка тестовых данных с помощью API для тестирования;&lt;/li&gt;
&lt;li&gt;Выполнение интеграционных тестов в интерфейсном приложении (участвует обычное API);&lt;/li&gt;
&lt;li&gt;Проверка результата выполнения с помощью API для тестирования.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Таким образом мы можем автоматизировать тестирование в процессах с участием больших баз данных.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
